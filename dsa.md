# STL（Standard Template Library）

---

## 核心概念
- 容器（containers）：用于储存和管理数据，是stl的基础
- 迭代器（iterators）：提供一种访问容器中元素的方式，类似指针，但更通用
- 算法（algorithms）：对容器的数据进行操作，例如排序、查找、复制等

---

## 容器

stl容器主要可以分为三类：
1. 序列容器：元素按照线性顺序排序
	- `vector`：动态数组
	- `list`：双向链表
	- `deque`：双端队列
2. 关联容器：元素不是按照插入顺序排列，而是根据键自动排序
	- `map`：映射
	- `set`：集合
	- `multimap`：多重映射
	- `multiset`：多重集合
3. 容器适配器：本身不是独立的容器，而是对于现有容器的封装，提供一种独特的数据访问方式
	- `stack`：栈
	- `queue`：队列
	- `priority_queue`：优先队列

**注意：** 容器适配器的主要优点在于强制执行特定的数据结构语义，可以直接使用vector实现栈，但可能会不小心使用 `[]`或 `at()`来访问栈中的元素，这违背了栈LIFO的原则。使用stack只提供了 `push()`、`pop()`、`top()`等方法，从根本上杜绝了不当操作   

---

### 序列容器

---

#### vector

vector内部使用一块 **连续的内存** 来存储元素，内部由三个指针（或迭代器）维护  
1. `start`：指向我内存块的起始位置
2. `finish`：指向最后一个元素的下一个位置
3. `end_of_storage`：指向最后一个可容纳元素的下一个位置

采用左闭右开的方式[start,end_of_storage)，这在STL中十分常见，简化了许多计算

这三个指针共同定义了vector的大小（size）和容量（capacity）
- `size`：当前vector中实际储存的元素数量，等于 `finish`-`start`
- `capacity`：vector在不重新分配内存的情况下可以容纳的最大元素数，等于 `end_of_storage-start`

当vector添加新元素时：
- 容量未满：size < capacity，新元素在finish指向的内存位置构造新元素，然后finish指针向后移动一位
- 容量已满：如果size = capacity，vector必须重新分配内存
	1. 分配一块更大的新内存块，通常是当前容量的2倍
	2. 将旧内存块中所有元素拷贝到新内存块中
	3. 释放旧内存
	4. 在新内存块添加新元素

重新分配内存的操作相对昂贵，涉及到内存分配、元素拷贝和内存释放，因此vector采用加倍扩容以减少重新分配的次数   

---

#### list

list将元素储存在**不连续的内存块**中，每个元素都是一个**独立**的节点，包含实际数据以及两个指针，并且为了便于管理，通常设立一个不储存实际数据的哨兵（sentinel）节点     
1. `prev`：指向链表前一个节点
2. `next`：指向链表后一个节点
3. `sentinel`：哨兵节点，该节点next指向list第一个元素，prev指向list最后一个元素

值得注意的是，若为空链表，则begin()和end()方法返回迭代器相同，均为哨兵节点   

这是STL迭代器设计的一个基本约定，可以使用相同的循环结构（例如 `for (auto it = l.begin(); it != l.end(); it++)`来遍历所有容器，无论它们是否为空  

在list中插入元素时： 
1. 创建新节点：分配一块内存，创建一个包含新元素和两个指针的新节点  
2. 定位插入点：通过现有节点迭代器 `it` 访问该节点以及前一个节点
3. 修改指针：
   - 将新节点的prev指向it的前一个节点
   - 将新节点的next指向it节点
   - 修改it前一个节点的next指针，指向新节点
   - 修改it节点的prev指针，指向新节点

这个过程只涉及四个指针的修改，时间复杂度为O(1)，但**仅是在已拥有指向目标节点迭代器的前提下**，而在实际运用中，我可能需要删除第i个节点，这**必须进行遍历**，查找节点的过程却是线性的，因此时间复杂度为O(N)  

所以在不知道迭代器的情况下，list和vector的插入操作时间复杂度都是O(N)，由于list查找需要遍历，且缺乏**缓存友好性**，它的实际运行时长可能比vector更长  

缓存友好性：  
缓存是位于cpu和主内存之间的一个小而快的内存，cpu访问数据时，会先到缓存里找，如果不在则前往内存中读取，造成延迟   

vector所有元素在内存中紧密相连，因此cpu在读取vector第一个元素时，很有可能会预先加载一整块数据到缓存中，所谓缓存友好性。而list中元素储存在独立分散的内存，会导致频繁的缓存未命中  

并且还值得注意的是，尽管vector在插入需要进行O(N)移动，但这种移动是物理上的**快速批量**，而list的O(N)却是逻辑上的**缓慢逐个**访问

---

#### deque

deque将数据分散储存在多个较小的、固定大小的内存块（或缓冲区）中，且为了管理这些分散的内存块，deque内部维护了一个映射表map，此外，deque利用两个迭代器实现功能
1. `map`：一个动态数组，元素是指向内存块的指针，负责管理分散的内存块
2. `start`：指向第一个元素，封装了三个信息
	- `_ptr`：指向deque第一个元素在内存的地址（第一个元素的偏移量不一定为0，但元素都是连续排列的）
	- `_chunk_ptr`：指向start当前所在内存块的起始地址
	- `_map_ptr`：指向map中指向指向start当前所在内存块的的起始地址（可以理解为`_chunk_ptr == *_map_ptr`）
3. `finish`：指向最后一个元素之后的迭代器，同样封装了上述三个信息

deque选择将数据储存在多个固定大小的内存块中是一种折中方案，为了同时兼顾在两端高效增删和快速随机访问两个目标  

在添加元素时，若当前内存块已满，只需要在map中添加新指针，指向一个新分配的内存块，这避免了vector那种大规模的内存分配和数据拷贝，同时利用偏移量和内存块大小计算出索引目标所在内存地址，实现快速访问  

值得注意的是deque和map都会预留两端的空闲空间，当map预留空间用尽时像vector一样扩容拷贝      

**当deque添加新元素时（以队首为例）：**  
1. 若内存块有空间：
   - `start` 迭代器的 `_ptr` 向前移动一位，指向新位置
   - `_chunk_ptr`和`_map_ptr`保持不变
2. 若缓冲区已满：
   - `_map_ptr`会向前移动一位，指向`map`数组中的新位置，若`map`没有空间进行一次指针拷贝扩容
   - `_chunk_ptr`指向新分配的内存块
   - `_ptr`指向新内存块的元素的位置

**deque的随机访问（deque[i]）**  
1. 定位缓冲区：deque利用 `start`的 `_map_ptr`和缓冲区大小，通过除法运算，在map中定位到目标元素所在缓冲区指针
   - `_map_ptr`提供start所在map索引
   - `_ptr`提供偏移量+i得到总步数
   - `总步数/缓冲区大小`，结合map得到目标元素所在内存块的指针
2. 定位元素：找到正确内存块后，通过`总步数%内存块大小`计算出目标元素在该内存块的偏移量  
3. 最终访问：通过map指针找到内存块，再通过_chunk_ptr指针找到元素    

---

### 关联容器  

---

#### map

map基于**红黑树**实现：
1. `color`：红黑树平衡的核心，确保树的高度不会失衡
2. `Key-Value Pair`：节点储存的实际数据
	- `Key`：键是不可改变的
	- `Value`：与键关联的数据
3. 指针：每个节点包含连接树中其他节点的指针
	- `left`：指向左子节点
	- `right`：指向右子节点
	- `parent`：指向父节点

由于红黑树自平衡二叉树的特点，map的查找、插入和删除操作都是O(logN)级别，并且所有元素都按照键的升序排列，每个节点独立分配，储存在不连续的内存中

---

#### set

set也是基于**红黑树**实现，运作方式与map相同，但在每个节点中只存储键，而无值  

set具有以下特点
1. set中的元素按照键的升序自动排列，遍历set时得到的序列总是有序的
2. set中的所有元素都是唯一的，无法插入一个已存在的元素
3. 由于红黑树的底层逻辑，相关操作时间复杂度都是O(logN)
4. set中的元素不可修改，只能先删除重新插入

封装好的红黑树

---

#### multimap

multimap与map非常相似，同样键值对的形似存储元素，但区别是multimap允许键重复  

即在multimap中一个键可以关联多个不同的值   

但相同键的元素并非存储在同一个节点中，而是在不同独立的节点中，multimap的红黑树在遇到等价的键时，不会拒绝插入，而是继续向右子树搜索，直到找到一个合适的位置插入，并且能够将所有等价键的节点在逻辑上排列在一起，实现一个键对应多个值的效果  

---

#### multiset
multiset同样是利用红黑树实现，插入逻辑与multimap相似，与set相比可以插入相同元素  

当作封装好的，可插入重复元素的红黑树使用  

---

### 容器适配器

---

#### stack  

stack通过封装deque作为底层容器来提供受限的访问接口，具有以下特点：
- 单一访问点：所有操作都集中在栈的顶部，无法访问或修改栈中的其他元素
- 后进先出（LIFO）：最后一个添加到战中的元素会第一个被移除

stack选择deque作为底层容器，而不用代码单独实现，体现了STL代码复用的哲学，内存管理，扩容机制，元素构造和析构等功能在deque中已经经过了严格的测试和优化，无需从头开始设计，增加编写和维护成本  

此外，stack模板允许用户自定义底层容器，deque为默认选择  

当压入元素（push()）时，stack会调用deque的push_back()方法，当弹出元素（pop()）时，stack会调用deque的pop_back()方法，需要注意弹出元素并不会返回被移除的元素，因为它会假定用户先调用top()来查看栈顶元素  

stack利用deque的back()方法来获取栈顶元素  

---

#### queue

queue同样通过封装deque作为底层容器来提供受限的访问接口，具有以下特点：
- 单一访问点：所有操作集中在队列两端，队尾用于添加元素，队首用于移除元素，无法访问和修改队列中的其他元素  
- 先进先出（FIFO）：第一个添加的元素是第一个被移除的

queue默认使用deque作为底层容器，保证push()和pop()操作都是O(1)级别，但也可以明确使用list（`queue<int,list<int>>`）  

同样，在队尾压入元素（push()）时，queue调用deque的push_back()方法，移除队首元素时，调用deque的pop_front()方法，利用deque的front()和back()方法返回队首和队尾的引用  

---

#### priority_queue

priority_queue默认使用vector作为底层容器，利用数据结构堆（heap）实现相关功能 

vector的连续内存非常适合实现堆，使得父子节点可以通过简单的数学运算来确定，而无需使用指针  

---