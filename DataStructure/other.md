## list

list将元素储存在**不连续的内存块**中，每个元素都是一个**独立**的节点，包含实际数据以及两个指针，并且为了便于管理，通常设立一个不储存实际数据的哨兵（sentinel）节点     
1. `prev`：指向链表前一个节点
2. `next`：指向链表后一个节点
3. `sentinel`：哨兵节点，该节点next指向list第一个元素，prev指向list最后一个元素

值得注意的是，若为空链表，则begin()和end()方法返回迭代器相同，均为哨兵节点   

这是STL迭代器设计的一个基本约定，可以使用相同的循环结构（例如 `for (auto it = l.begin(); it != l.end(); it++)`来遍历所有容器，无论它们是否为空  

在list中插入元素时： 
1. 创建新节点：分配一块内存，创建一个包含新元素和两个指针的新节点  
2. 定位插入点：通过现有节点迭代器 `it` 访问该节点以及前一个节点
3. 修改指针：
   - 将新节点的prev指向it的前一个节点
   - 将新节点的next指向it节点
   - 修改it前一个节点的next指针，指向新节点
   - 修改it节点的prev指针，指向新节点

这个过程只涉及四个指针的修改，时间复杂度为O(1)，但**仅是在已拥有指向目标节点迭代器的前提下**，而在实际运用中，我可能需要删除第i个节点，这**必须进行遍历**，查找节点的过程却是线性的，因此时间复杂度为O(N)  

所以在不知道迭代器的情况下，list和vector的插入操作时间复杂度都是O(N)，由于list查找需要遍历，且缺乏**缓存友好性**，它的实际运行时长可能比vector更长  

缓存友好性：  
缓存是位于cpu和主内存之间的一个小而快的内存，cpu访问数据时，会先到缓存里找，如果不在则前往内存中读取，造成延迟   

vector所有元素在内存中紧密相连，因此cpu在读取vector第一个元素时，很有可能会预先加载一整块数据到缓存中，所谓缓存友好性。而list中元素储存在独立分散的内存，会导致频繁的缓存未命中  

并且还值得注意的是，尽管vector在插入需要进行O(N)移动，但这种移动是物理上的**快速批量**，而list的O(N)却是逻辑上的**缓慢逐个**访问

---

## deque

deque将数据分散储存在多个较小的、固定大小的内存块（或缓冲区）中，且为了管理这些分散的内存块，deque内部维护了一个映射表map，此外，deque利用两个迭代器实现功能
1. `map`：一个动态数组，元素是指向内存块的指针，负责管理分散的内存块
2. `start`：指向第一个元素，封装了三个信息
	- `_ptr`：指向deque第一个元素在内存的地址（第一个元素的偏移量不一定为0，但元素都是连续排列的）
	- `_chunk_ptr`：指向start当前所在内存块的起始地址
	- `_map_ptr`：指向map中指向指向start当前所在内存块的的起始地址（可以理解为`_chunk_ptr == *_map_ptr`）
3. `finish`：指向最后一个元素之后的迭代器，同样封装了上述三个信息

deque选择将数据储存在多个固定大小的内存块中是一种折中方案，为了同时兼顾在两端高效增删和快速随机访问两个目标  

在添加元素时，若当前内存块已满，只需要在map中添加新指针，指向一个新分配的内存块，这避免了vector那种大规模的内存分配和数据拷贝，同时利用偏移量和内存块大小计算出索引目标所在内存地址，实现快速访问  

值得注意的是deque和map都会预留两端的空闲空间，当map预留空间用尽时像vector一样扩容拷贝      

**当deque添加新元素时（以队首为例）：**  
1. 若内存块有空间：
   - `start` 迭代器的 `_ptr` 向前移动一位，指向新位置
   - `_chunk_ptr`和`_map_ptr`保持不变
2. 若缓冲区已满：
   - `_map_ptr`会向前移动一位，指向`map`数组中的新位置，若`map`没有空间进行一次指针拷贝扩容
   - `_chunk_ptr`指向新分配的内存块
   - `_ptr`指向新内存块的元素的位置

**deque的随机访问（deque[i]）**  
1. 定位缓冲区：deque利用 `start`的 `_map_ptr`和缓冲区大小，通过除法运算，在map中定位到目标元素所在缓冲区指针
   - `_map_ptr`提供start所在map索引
   - `_ptr`提供偏移量+i得到总步数
   - `总步数/缓冲区大小`，结合map得到目标元素所在内存块的指针
2. 定位元素：找到正确内存块后，通过`总步数%内存块大小`计算出目标元素在该内存块的偏移量  
3. 最终访问：通过map指针找到内存块，再通过_chunk_ptr指针找到元素    

---

## map

map基于**红黑树**实现：
1. `color`：红黑树平衡的核心，确保树的高度不会失衡
2. `Key-Value Pair`：节点储存的实际数据
	- `Key`：键是不可改变的
	- `Value`：与键关联的数据
3. 指针：每个节点包含连接树中其他节点的指针
	- `left`：指向左子节点
	- `right`：指向右子节点
	- `parent`：指向父节点

由于红黑树自平衡二叉树的特点，map的查找、插入和删除操作都是O(logN)级别，并且所有元素都按照键的升序排列，每个节点独立分配，储存在不连续的内存中

---

## multimap

multimap与map非常相似，同样键值对的形似存储元素，但区别是multimap允许键重复  

即在multimap中一个键可以关联多个不同的值   

但相同键的元素并非存储在同一个节点中，而是在不同独立的节点中，multimap的红黑树在遇到等价的键时，不会拒绝插入，而是继续向右子树搜索，直到找到一个合适的位置插入，并且能够将所有等价键的节点在逻辑上排列在一起，实现一个键对应多个值的效果  

---

## set

set也是基于**红黑树**实现，运作方式与map相同，但在每个节点中只存储键，而无值  

set具有以下特点
1. set中的元素按照键的升序自动排列，遍历set时得到的序列总是有序的
2. set中的所有元素都是唯一的，无法插入一个已存在的元素
3. 由于红黑树的底层逻辑，相关操作时间复杂度都是O(logN)
4. set中的元素不可修改，只能先删除重新插入

封装好的红黑树

---

## multiset
multiset同样是利用红黑树实现，插入逻辑与multimap相似，与set相比可以插入相同元素  

当作封装好的，可插入重复元素的红黑树使用  
